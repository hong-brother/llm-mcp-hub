"""Memory service for session export and compression"""
import logging
from datetime import datetime
from enum import Enum
from typing import Any

from llm_mcp_hub.domain import Session
from .session import SessionService
from .chat import ChatService

logger = logging.getLogger(__name__)


class CompressionLevel(str, Enum):
    """Compression level for memory export"""

    NONE = "none"  # Full conversation
    LOW = "low"  # Summary + key messages
    MEDIUM = "medium"  # Topic summary + decisions
    HIGH = "high"  # Keywords only


class MemoryService:
    """Service for exporting and compressing session memory"""

    def __init__(
        self,
        session_service: SessionService,
        chat_service: ChatService,
    ):
        self._session_service = session_service
        self._chat_service = chat_service

    async def export_memory(
        self,
        session_id: str,
        compression: CompressionLevel = CompressionLevel.MEDIUM,
        provider: str = "claude",
        format: str = "markdown",
    ) -> dict[str, Any]:
        """
        Export session memory with optional compression.

        Returns dict with:
        - session_id: str
        - compression: str
        - format: str
        - content: str - Formatted memory content
        - metadata: dict - Session metadata
        """
        session = await self._session_service.get_session(session_id)

        if compression == CompressionLevel.NONE:
            content = self._format_full_conversation(session)
        else:
            content = await self._compress_conversation(session, compression, provider)

        if format == "json":
            return {
                "session_id": session_id,
                "compression": compression.value,
                "format": format,
                "compressed_memory": content,
                "metadata": {
                    "provider": session.provider,
                    "model": session.model,
                    "message_count": len(session.messages),
                    "created_at": session.created_at.isoformat(),
                },
            }

        return {
            "session_id": session_id,
            "compression": compression.value,
            "format": format,
            "content": content,
            "metadata": {
                "provider": session.provider,
                "model": session.model,
                "message_count": len(session.messages),
                "created_at": session.created_at.isoformat(),
            },
        }

    def _format_full_conversation(self, session: Session) -> str:
        """Format full conversation as markdown"""
        lines = [
            f"# Session Memory: {session.id}",
            "",
            "## Metadata",
            f"- **Created**: {session.created_at.isoformat()}",
            f"- **Provider**: {session.provider}",
            f"- **Model**: {session.model}",
            f"- **Messages**: {len(session.messages)}",
            "",
        ]

        if session.system_prompt:
            lines.extend([
                "## System Prompt",
                session.system_prompt,
                "",
            ])

        lines.append("## Conversation")

        for msg in session.messages:
            role = "User" if msg.role.value == "user" else "Assistant"
            lines.extend([
                "",
                f"### {role} ({msg.timestamp.strftime('%Y-%m-%d %H:%M:%S')})",
                msg.content,
            ])

        lines.extend(["", "---", "*Generated by LLM MCP Hub*"])
        return "\n".join(lines)

    async def _compress_conversation(
        self,
        session: Session,
        compression: CompressionLevel,
        provider: str,
    ) -> str:
        """Compress conversation using LLM"""
        if not session.messages:
            return "# Empty Session\nNo messages to summarize."

        # Build conversation text
        conversation_text = "\n".join(
            f"{'User' if m.role.value == 'user' else 'Assistant'}: {m.content}"
            for m in session.messages
        )

        # Build compression prompt based on level
        if compression == CompressionLevel.LOW:
            prompt = f"""Summarize this conversation, keeping important details and key messages:

{conversation_text}

Format as markdown with:
- Brief summary
- Key decisions or conclusions
- Important quotes or statements"""

        elif compression == CompressionLevel.MEDIUM:
            prompt = f"""Create a concise summary of this conversation focusing on:
1. Main topics discussed
2. Decisions made
3. Action items or next steps

Conversation:
{conversation_text}

Format as markdown with clear sections."""

        else:  # HIGH
            prompt = f"""Extract only the essential keywords and key points from this conversation:

{conversation_text}

Format as a brief bullet list of keywords and concepts only."""

        try:
            result = await self._chat_service.chat(
                prompt=prompt,
                provider=provider,
                timeout=60.0,
            )
            return result["response"]
        except Exception as e:
            logger.error(f"Failed to compress conversation: {e}")
            # Fallback to simple summary
            return self._simple_summary(session)

    def _simple_summary(self, session: Session) -> str:
        """Simple summary without LLM (fallback)"""
        lines = [
            f"# Session Summary: {session.id}",
            "",
            f"- **Provider**: {session.provider}",
            f"- **Model**: {session.model}",
            f"- **Messages**: {len(session.messages)}",
            f"- **Created**: {session.created_at.isoformat()}",
            "",
            "## Message Overview",
        ]

        user_count = sum(1 for m in session.messages if m.role.value == "user")
        assistant_count = len(session.messages) - user_count

        lines.extend([
            f"- User messages: {user_count}",
            f"- Assistant messages: {assistant_count}",
        ])

        return "\n".join(lines)

    async def close_session_with_memory(
        self,
        session_id: str,
        compression: CompressionLevel = CompressionLevel.MEDIUM,
        provider: str = "claude",
    ) -> dict[str, Any]:
        """Close session and generate compressed memory"""
        # Export memory first
        memory = await self.export_memory(
            session_id=session_id,
            compression=compression,
            provider=provider,
            format="markdown",
        )

        # Close session
        session = await self._session_service.close_session(session_id)

        return {
            "success": True,
            "session_id": session_id,
            "status": session.status.value,
            "compressed_memory": memory["content"],
        }
